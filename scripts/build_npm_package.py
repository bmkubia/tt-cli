#!/usr/bin/env python3
"""Stage and optionally package the tt CLI npm module."""

from __future__ import annotations

import argparse
import json
import shutil
import subprocess
import tempfile
from pathlib import Path


REPO_ROOT = Path(__file__).resolve().parent.parent
PACKAGE_ROOTS = {
    "tt-cli": REPO_ROOT / "npm" / "tt-cli",
}
VENDOR_DIR = "vendor"
TARGET_BINARIES = {
    "x86_64-unknown-linux-musl": "tt",
    "aarch64-unknown-linux-musl": "tt",
    "x86_64-apple-darwin": "tt",
    "aarch64-apple-darwin": "tt",
    "x86_64-pc-windows-msvc": "tt.exe",
}


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Build or stage the tt CLI npm package.")
    parser.add_argument(
        "--package",
        choices=tuple(PACKAGE_ROOTS.keys()),
        default="tt-cli",
        help="Which package definition to stage.",
    )
    parser.add_argument(
        "--version",
        help="Version to write into package.json. Required unless --release-version is set.",
    )
    parser.add_argument(
        "--release-version",
        help="Version to stage for release (alias for --version).",
    )
    parser.add_argument(
        "--target",
        dest="targets",
        action="append",
        choices=tuple(TARGET_BINARIES.keys()),
        help="Limit staging to specific target triples (default: all supported targets).",
    )
    parser.add_argument(
        "--staging-dir",
        type=Path,
        help="Directory to stage the package contents (defaults to a temp dir).",
    )
    parser.add_argument(
        "--pack-output",
        type=Path,
        help="Path to the tarball generated by npm pack.",
    )
    parser.add_argument(
        "--vendor-src",
        type=Path,
        help="Directory that already contains vendor/<target>/tt binaries.",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    package = args.package
    version = args.release_version or args.version
    if not version:
        raise RuntimeError("Must provide --version or --release-version.")
    targets = args.targets or list(TARGET_BINARIES.keys())

    staging_dir, created_temp = prepare_staging_dir(args.staging_dir)

    try:
        stage_sources(package, staging_dir, version)

        if args.vendor_src is None:
            raise RuntimeError("Must provide --vendor-src when staging for release.")
        copy_native_binaries(args.vendor_src, staging_dir, targets)

        if args.pack_output is not None:
            run_npm_pack(staging_dir, args.pack_output)
            print(f"npm pack output written to {args.pack_output}")
        else:
            print(f"Staged npm package in {staging_dir}")
    finally:
        if created_temp:
            # Preserve the directory for debugging by printing the path.
            print(f"Temporary staging dir: {staging_dir}")

    return 0


def prepare_staging_dir(staging_dir: Path | None) -> tuple[Path, bool]:
    if staging_dir is not None:
        staging_dir = staging_dir.resolve()
        staging_dir.mkdir(parents=True, exist_ok=True)
        if any(staging_dir.iterdir()):
            raise RuntimeError(f"Staging directory {staging_dir} is not empty.")
        return staging_dir, False

    temp_dir = Path(tempfile.mkdtemp(prefix="tt-cli-npm-stage-"))
    return temp_dir, True


def stage_sources(package: str, staging_dir: Path, version: str) -> None:
    package_root = PACKAGE_ROOTS[package]
    shutil.copytree(package_root / "bin", staging_dir / "bin")
    shutil.copy2(package_root / "README.md", staging_dir / "README.md")

    with open(package_root / "package.json", "r", encoding="utf-8") as fh:
        package_json = json.load(fh)
    package_json["version"] = version

    with open(staging_dir / "package.json", "w", encoding="utf-8") as fh:
        json.dump(package_json, fh, indent=2)
        fh.write("\n")


def copy_native_binaries(vendor_src: Path, staging_dir: Path, targets: list[str]) -> None:
    vendor_src = vendor_src.resolve()
    staging_vendor = staging_dir / VENDOR_DIR
    staging_vendor.mkdir(parents=True, exist_ok=True)

    for target in targets:
        binary_name = TARGET_BINARIES[target]
        src_path = vendor_src / target / "tt" / binary_name
        if not src_path.exists():
            raise RuntimeError(f"Missing binary for {target} at {src_path}")

        dest_dir = staging_vendor / target / "tt"
        dest_dir.mkdir(parents=True, exist_ok=True)
        shutil.copy2(src_path, dest_dir / binary_name)


def run_npm_pack(staging_dir: Path, pack_output: Path) -> None:
    pack_output = pack_output.resolve()
    pack_output.parent.mkdir(parents=True, exist_ok=True)

    result = subprocess.run(
        ["npm", "pack", "--pack-destination", str(pack_output.parent)],
        cwd=staging_dir,
        text=True,
        capture_output=True,
        check=True,
    )
    produced = (result.stdout or "").strip().splitlines()[-1]
    if not produced:
        raise RuntimeError("npm pack did not report an output tarball.")
    produced_path = pack_output.parent / produced
    produced_path.rename(pack_output)


if __name__ == "__main__":
    raise SystemExit(main())
